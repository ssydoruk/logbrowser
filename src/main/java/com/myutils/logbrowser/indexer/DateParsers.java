/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.myutils.logbrowser.indexer;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.PatternSyntaxException;
import org.apache.commons.lang3.StringUtils;

/**
 *
 * @author ssydoruk
 */
final class DateParsers {

    private ArrayList<Parser.DateFmt> dateFormats = new ArrayList<>();
    private ArrayList<Parser.DateFmt> prefferedFormats = null;
    private boolean checkRegex = true;

    private Parser.DateFmt lastFmtMatched;

    public DateParsers() {
// default format for Apache WebServer, as generated by GWS        
        AddFormat("^\\d{2}/\\w{3}/\\d{4}:\\d{2}:\\d{2}:\\d{2}", "dd/MMM/yyyy:HH:mm:ss", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages

        // default standard Genesys formats
        AddFormat("^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "HH:mm:ss.SSS", Parser.DateIncluded.DATE_NOT_INCLUDED); // format for short timestamp
        AddFormat("^\\d{4}/\\d{2}/\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy/MM/dd'T'HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd'T'HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages

        AddFormat("^\\d{4}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy/MM/dd HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
        AddFormat("^\\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "MM/dd/yyyy HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
        AddFormat("^\\d{2}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "MM/dd/yy HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd'T'HH:mm:ss.SSS", Parser.DateIncluded.DATE_INCUDED); // full timestamp used in Genesys messages
//         <!--Sun Jun  5 15:22:21 2016.741 -->
        AddFormat("^\\w{3} \\w{3}\\s+\\d{1,2} \\d{2}:\\d{2}:\\d{2} \\d{4}\\.\\d{3}", "EEE MMM d HH:mm:ss yyyy.SSS", Parser.DateIncluded.DATE_INCUDED);

//    	<!--Thu 11 Aug 2016 09:01:46 AM CDT.060-->
        AddFormat("^\\w{3} \\d{2} \\w{3} \\d{4} \\d{2}:\\d{2}:\\d{2} \\w{2} \\w{3}\\.\\d{3}", "EEE d MMM yyyy HH:mm:ss a zzz.SSS", Parser.DateIncluded.DATE_INCUDED);

//        Start time: [Wed Jan 17 08:37:07 CST 2018]
        AddFormat("^\\w{3} \\w{3} \\d{2} \\d{2}:\\d{2}:\\d{2} \\w{3} \\d{4}", "EEE MMM y HH:mm:ss zzz yyyy", Parser.DateIncluded.DATE_INCUDED);

    }

    public void setCheckRegex(boolean checkRegex) {
        this.checkRegex = checkRegex;
        Main.logger.trace("checkRegex " + checkRegex);
    }

    public void setPrefferedFormats(ArrayList<Parser.DateFmt> _prefferedFormats) {
        // if null passed, it will clear prefferedFormats and so parser will use default set of formats
        // null to fix bug with multiple SIP Server files
        this.prefferedFormats = _prefferedFormats;
        Main.logger.trace("setPrefferedFormats");
    }

    /*
        always adds to the head of list. So added last will be checked first
     */
    public void AddFormat(String regexDate, String fmt, Parser.DateIncluded dateIncluded) throws PatternSyntaxException {
        dateFormats.add(0, new Parser.DateFmt(regexDate, fmt, dateIncluded));
    }

    public void AddFormat(Parser.DateFmt fmt) throws PatternSyntaxException {
        dateFormats.add(0, fmt);
    }

    private String checkDateStr(String timestr) {
        if (timestr != null && !timestr.isEmpty()) {
            if (Character.isSpaceChar(timestr.charAt(0))) {
                return null;
            }
        }
        return timestr;
    }

    public Parser.DateFmt getLastFmtMatched() {
        return lastFmtMatched;
    }

    public static final LocalDateTime parsingStarted = LocalDateTime.now();

    public DateParsed parseFormatDate(String s) throws Exception {
        return parseFormatDate(s, parsingStarted);
    }

    public DateParsed parseFormatDate(String s, LocalDateTime lastKnownDate) throws Exception {
        Matcher m;
//        s = checkDateStr(s);
        if (s != null && !s.isEmpty()) {
            ArrayList<Parser.DateFmt> formats = getFormats();

            for (Parser.DateFmt dateFormat : formats) {
//                Main.logger.trace("Parsing date for [" + s + "]" + " against format " + dateFormat);
//                if (checkRegex) {
                if ((m = dateFormat.pattern.matcher(s)).find()) {
                    lastFmtMatched = dateFormat;
                    moveTop(formats, dateFormat);
                    String d = s.substring(0, m.end(0));

                    try {
                        return new DateParsed(s, d,
                                s.substring(m.end(0)),
                                dateFormat.parseDate(d, m, lastKnownDate));
                    } catch (ParseException parseException) {
                        Main.logger.error("Cannot parse [" + d + "]: " + parseException.getMessage() + " format: " + dateFormat.toString(), parseException);
                        return null;
                    }
                }

            }
        }
        Main.logger.trace("parseFormatDate() date NOT parsed from [" + s + "]");
        lastFmtMatched = null;
        return null;
    }

    private ArrayList<Parser.DateFmt> getFormats() {
        return (prefferedFormats != null) ? prefferedFormats : dateFormats;
    }

    private void moveTop(ArrayList<Parser.DateFmt> formats, Parser.DateFmt dateFormat) {
        int indexOf = formats.indexOf(dateFormat);
        if (indexOf > 0) {
            formats.remove(indexOf);
            formats.add(0, dateFormat);

        }
    }

}

final class DateParsed {

    String date;
    String rest;
    LocalDateTime fmtDate = null;
    String orig;

    DateParsed(DateParsed d) {
        date = d.date;
        rest = StringUtils.trimToEmpty(rest);
        orig = d.orig;
        fmtDate = d.fmtDate;
    }

    DateParsed(String orig, String date, String rest) {
        this.date = date;
        this.rest = StringUtils.trimToEmpty(rest);
        this.orig = orig;
    }

    DateParsed(String orig, String date, String rest, LocalDateTime f) {
        this.orig = orig;
        this.date = date;
        this.rest = StringUtils.trimToEmpty(rest);
        this.fmtDate = f;
        Main.logger.trace(toString());
    }

    @Override
    public String toString() {
        return "DateParsed{" + "date=" + date + ", rest=" + rest + ", fmtDate=" + fmtDate + '}';
    }

    void addDay() {
        fmtDate = fmtDate.plusDays(1);
        Main.logger.trace("added day to " + this);
    }

    private static final ZoneId zo = ZoneId.systemDefault();

    long getUTCms() {
        return fmtDate.atZone(zo).toEpochSecond() * 1000 + fmtDate.getNano() / 1000 / 1000;

    }

}
