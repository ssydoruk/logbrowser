/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.myutils.logbrowser.indexer;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.PatternSyntaxException;
import org.apache.commons.lang3.StringUtils;


/**
 *
 * @author ssydoruk
 */
class DateParsers {

    private ArrayList<Parser.DateFmt> dateFormats = new ArrayList<>();
    private ArrayList<Parser.DateFmt> prefferedFormats = null;
    private boolean checkRegex = true;

    public void setCheckRegex(boolean checkRegex) {
        this.checkRegex = checkRegex;
        Main.logger.trace("checkRegex " + checkRegex);
    }

    public void setPrefferedFormats(ArrayList<Parser.DateFmt> _prefferedFormats) {
        // if null passed, it will clear prefferedFormats and so parser will use default set of formats
        // null to fix bug with multiple SIP Server files
        this.prefferedFormats = _prefferedFormats;
        Main.logger.trace("setPrefferedFormats");
    }
    private Parser.DateFmt lastFmtMatched;

    public DateParsers() {
// default format for Apache WebServer, as generated by GWS        
        AddFormat("^\\d{2}/\\w{3}/\\d{4}:\\d{2}:\\d{2}:\\d{2}", "dd/MMM/yyyy:HH:mm:ss"); // full timestamp used in Genesys messages
//        AddFormat("^\\d{2}/\\w{3}/\\d{4}:\\d{2}:\\d{2}:\\d{2}", "dd/MMM/yyyy:HH:mm:ss"); // full timestamp used in Genesys messages
        // default standard Genesys formats
        AddFormat("^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "HH:mm:ss.SSS"); // format for short timestamp
        AddFormat("^\\d{4}/\\d{2}/\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy/MM/dd'T'HH:mm:ss.SSS"); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd'T'HH:mm:ss.SSS"); // full timestamp used in Genesys messages

        AddFormat("^\\d{4}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy/MM/dd HH:mm:ss.SSS"); // full timestamp used in Genesys messages
        AddFormat("^\\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "MM/dd/yyyy HH:mm:ss.SSS"); // full timestamp used in Genesys messages
        AddFormat("^\\d{2}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "MM/dd/yy HH:mm:ss.SSS"); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd HH:mm:ss.SSS"); // full timestamp used in Genesys messages
        AddFormat("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", "yyyy-MM-dd'T'HH:mm:ss.SSS"); // full timestamp used in Genesys messages
//         <!--Sun Jun  5 15:22:21 2016.741 -->
        AddFormat("^\\w{3} \\w{3}\\s+\\d{1,2} \\d{2}:\\d{2}:\\d{2} \\d{4}\\.\\d{3}", "EEE MMM d HH:mm:ss yyyy.SSS");

//    	<!--Thu 11 Aug 2016 09:01:46 AM CDT.060-->
        AddFormat("^\\w{3} \\d{2} \\w{3} \\d{4} \\d{2}:\\d{2}:\\d{2} \\w{2} \\w{3}\\.\\d{3}", "EEE d MMM yyyy HH:mm:ss aa zzz.SSS");

//        Start time: [Wed Jan 17 08:37:07 CST 2018]
        AddFormat("^\\w{3} \\w{3} \\d{2} \\d{2}:\\d{2}:\\d{2} \\w{3} \\d{4}", "EEE MMM y HH:mm:ss zzz yyyy");

    }

    /*
        always adds to the head of list. So added last will be checked first
     */
    public void AddFormat(String regexDate, String fmt) throws PatternSyntaxException {
        dateFormats.add(0, new Parser.DateFmt(regexDate, fmt));
    }

    public void AddFormat(Parser.DateFmt fmt) throws PatternSyntaxException {
        dateFormats.add(0, fmt);
    }

    private String checkDateStr(String timestr) {
        if (timestr != null && !timestr.isEmpty()) {
            if (Character.isSpaceChar(timestr.charAt(0))) {
                return null;
            }
        }
        return timestr;
    }

//    public DateParsed parseDate(String s) throws Exception {
//        Matcher m;
//        s = checkDateStr(s);
//        if (s != null) {
//            ArrayList<Parser.DateFmt> formats = getFormats();
//            for (Parser.DateFmt dateFormat : formats) {
////                Main.logger.trace("Parsing date for [" + s + "]" + " against format " + dateFormat);
//                if ((m = dateFormat.pattern.matcher(s)).find()) {
//                    Main.logger.trace("\tregex found; now parsing date");
//                    lastFmtMatched = dateFormat;
//                    moveTop(formats, dateFormat);
//                    return new DateParsed(s, s.substring(0, m.end(0)),
//                            s.substring(m.end(0)));
//                }
//            }
//        }
//        lastFmtMatched = null;
//        Main.logger.trace("parseDate() date NOT parsed from [" + s + "]");
//        return null;
//    }
    public Parser.DateFmt getLastFmtMatched() {
        return lastFmtMatched;
    }

    public DateParsed parseFormatDate(String s) throws Exception {
        Matcher m;
        s = checkDateStr(s);
        if (s != null && !s.isEmpty()) {
            ArrayList<Parser.DateFmt> formats = getFormats();

            for (Parser.DateFmt dateFormat : formats) {
                Main.logger.trace("Parsing date for [" + s + "]" + " against format " + dateFormat);
//                if (checkRegex) {
                if ((m = dateFormat.pattern.matcher(s)).find()) {
                    lastFmtMatched = dateFormat;
                    moveTop(formats, dateFormat);
                    String d = s.substring(0, m.end(0));

                    try {
                        return new DateParsed(s, d,
                                s.substring(m.end(0)),
                                dateFormat.parseDate(d, m));
                    } catch (ParseException parseException) {
                        Main.logger.error("Cannot parse [" + d + "]: " + parseException.getMessage() + " format: " + dateFormat.toString(), parseException);
                        return null;
                    }
                }
//                } else {
//                    if (dateFormat.isReplNull()) {
//                        int l = dateFormat.getFmtLength();
//                        if (l <= s.length()) {
//                            String d = s.substring(0, l);
//                            try {
//                                Date dd = dateFormat.parseDate(d);
//                                return new DateParsed(s, d,
//                                        s.substring(l),
//                                        dd);
//                            } catch (ParseException parseException) {
//                                Main.logger.trace("ex: Not recognized fmt [" + dateFormat + "] in [" + d + "]");
//                            }
//                        }
//
//                    } else if ((m = dateFormat.pattern.matcher(s)).find()) {
//                        lastFmtMatched = dateFormat;
//                        moveTop(formats, dateFormat);
//                        String d = s.substring(0, m.end(0));
//
//                        try {
//                            return new DateParsed(s, d,
//                                    s.substring(m.end(0)),
//                                    dateFormat.parseDate(d, m));
//                        } catch (ParseException parseException) {
//                            Main.logger.error("Cannot parse [" + d + "]: " + parseException.getMessage() + " format: " + dateFormat.toString(), parseException);
//                            return null;
//                        }
//                    }
//
//                }
            }
        }
        Main.logger.trace("parseFormatDate() date NOT parsed from [" + s + "]");
        lastFmtMatched = null;
        return null;
    }

    private ArrayList<Parser.DateFmt> getFormats() {
        return (prefferedFormats != null) ? prefferedFormats : dateFormats;
    }

    private void moveTop(ArrayList<Parser.DateFmt> formats, Parser.DateFmt dateFormat) {
        int indexOf = formats.indexOf(dateFormat);
        if (indexOf > 0) {
            formats.remove(indexOf);
            formats.add(0, dateFormat);

        }
    }

}

class DateParsed {

    String date;
    String rest;
    Date fmtDate = null;
    String orig;

    DateParsed(DateParsed d) {
        date = d.date;
        rest = StringUtils.trimToEmpty(rest);
        orig = d.orig;
        fmtDate = d.fmtDate;
    }
    
    private static final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");


    @Override
    public String toString() {
        return "DateParsed{" + "date=" + date + ", rest=" + rest + ", fmtDate=" + dateFormat.format(fmtDate) + '}';
    }

    DateParsed(String orig, String date, String rest) {
        this.date = date;
        this.rest = StringUtils.trimToEmpty(rest);
        this.orig = orig;
    }

    DateParsed(String orig, String date, String rest, Date f) {
        this.orig = orig;
        this.date = date;
        this.rest = StringUtils.trimToEmpty(rest);
        this.fmtDate = f;
        Main.logger.trace(this);
    }

    void addDay() {
        fmtDate = DateUtil.addDays(fmtDate, 1);
        Main.logger.trace("added day to " + this);
    }

}
